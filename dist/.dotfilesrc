#!/usr/bin/env bash

#  BASH Settings
set -o errexit
set -o errtrace
set -o nounset
set -o pipefail

# Constants

export DEBIAN_FRONTEND=noninteractive

## Colors

export NOCOLOR='\033[0m'
export RED='\033[0;31m'
export GREEN='\033[0;32m'
# shellcheck disable=SC2034
export ORANGE='\033[0;33m'
export BLUE='\033[0;34m'
# shellcheck disable=SC2034
export PURPLE='\033[0;35m'
# shellcheck disable=SC2034
export CYAN='\033[0;36m'
# shellcheck disable=SC2034
export LIGHTGRAY='\033[0;37m'
# shellcheck disable=SC2034
export DARKGRAY='\033[1;30m'
# shellcheck disable=SC2034
export LIGHTRED='\033[1;31m'
export LIGHTGREEN='\033[1;32m'
export YELLOW='\033[1;33m'
export LIGHTBLUE='\033[1;34m'
# shellcheck disable=SC2034
export LIGHTPURPLE='\033[1;35m'
# shellcheck disable=SC2034
export LIGHTCYAN='\033[1;36m'
export WHITE='\033[1;37m'

## :Colors

if [[ -z "${BASE_PATH:-}" ]]; then
  readonly BASE_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
fi
if [[ -z "${WORK_DIR:-}" ]]; then
  readonly WORK_DIR="${WORK_DIR:-"$BASE_PATH"}"
fi

export PKGS_PATH="${WORK_DIR}/packages"
readonly PKGS_PATH
# export PKGS_PATH="${WORK_DIR}/packages"

set -o allexport
. "${WORK_DIR}/.env"
set +o allexport

# Functions

## echo functions

echoec() {
  local -r color="${2-$BLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "$*"
  else
    echo -e "${color}$*${NOCOLOR}" >&2
  fi
}
export -f echoec

echoc() {
  local -r color="${2-$BLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "$*"
  else
    echo -e "${color}$*${NOCOLOR}"
  fi
}
export -f echoc

err() {
  local -r color="${2-$RED}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "ERROR> $*" >&2
  else
    echo -e "${color}ERROR> $*${NOCOLOR}" >&2
  fi
}
export -f err

inf() {
  local -r color="${2-$LIGHTBLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "INFO> $*"
  else
    echo -e "${color}INFO> $*${NOCOLOR}"
  fi
}
export -f inf

infn() {
  local -r color="${2-$LIGHTBLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e -n "INFO> $*"
  else
    echo -e -n "${color}INFO> $*${NOCOLOR}"
  fi
}
export -f infn

debug() {
  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo "DEBUG> $*"
  fi
}
export -f debug

## :echo functions


## dotfiles functions

__install_plugin() {
  local -r plugin="$1"

  local -r pkg="$plugin"
  local -r plugin_file_path="${PKGS_PATH}/${pkg}/content/${plugin}.plugin.bash"
  local -r plugin_file_dest_path="${BASH_PLUGINS_DIR}/${plugin}.plugin.bash"

  local -r msg="Installing bash plugin"

  inf "${msg}: ${plugin}"

  if [[ ! -f "$plugin_file_path" ]]; then
    err "${msg}: ${plugin}, plugin doesn't exist in: $plugin_file_path"
    return 10
  fi

  if [[ ! -d "$BASH_PLUGINS_DIR" ]]; then
    err "${msg}: ${plugin}, plugins dir doesn't exist: $BASH_PLUGINS_DIR"
    return 11
  fi

  ln --symbolic --verbose "$plugin_file_path" "$plugin_file_dest_path" || {
    err "${msg}: ${plugin}, creating link"
    return 12
  }
  echo "BASHC_PLUGINS+=($plugin)" >> "$BASH_GEN_SETTINGS_FILE" || {
    err "${msg}: ${plugin}, adding plugin to settings"
    return 13
  }

  inf "DONE. ${msg}: ${plugin}" "$GREEN"
  return 0
}
export -f __install_plugin

__install_package() {
  local -r pkg="$1"

  local -r pkg_dir="${PKGS_PATH}/${pkg}"
  local -r setup_file_path="${pkg_dir}/setup"
  local -r plugin_file_path="${pkg_dir}/content/${pkg}.plugin.bash"
  local -r msg='Installing package'

  if [[ ! -f "$setup_file_path" ]]; then
    err "${msg}: ${pkg}, package doesn't exist: $setup_file_path"
    return 10
  fi

  # Idempotent
  type -P "$pkg" &> /dev/null && {
    inf "${pkg} currently installed"
    return 0
  }

  env PKG_CONTENT="${PKGS_PATH}/${pkg}/content" PKG_PATH="${PKGS_PATH}/${pkg}" bash "$setup_file_path" || {
    err "${msg}: ${pkg}, executing package setup"
    return 11
  }

  if [[ -f "$plugin_file_path" ]]; then
    __install_plugin "$pkg" || {
      err "${msg}: ${pkg}, installing bash plugin"
      return 12
    }
  fi

  return 0
}
export -f __install_package

dotf-i() {
  local -r pkg="$1"
  # local -r color="\e[3$(( "$RANDOM" * 6 / 32767 + 1 ))m"

 if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
  local -r msg="Installing package ${pkg}"
  echo -e "\n> ${msg}"
  if __install_package "$1"; then
    echo -e "> DONE. ${msg}"
  else
    echo -e "> FAIL. ${msg}"
  fi
 else
   local -r msg="${WHITE} Installing package${NOCOLOR} ${YELLOW}${pkg}${NOCOLOR}"
   echo -e "\n${WHITE}>${NOCOLOR}${msg}"
  if __install_package "$1"; then
    echo -e "${WHITE}>${NOCOLOR}${LIGHTGREEN} DONE.${msg}${NOCOLOR}"
  else
    echo -e "${WHITE}>${NOCOLOR}${LIGHTRED} FAIL.${msg}${NOCOLOR}"
  fi
 fi
}
export -f dotf-i

## :dotfiles functions

create_desktop_file(){
	local -r name="$1"
  local -r comment="$2"
  local -r categories="$3"
  local -r keywords="$4"
  local -r exec="$5"
  local -r icon="$6"
  local -r startupWMClass=${7:-}
  local -r fileName="${8:-$name}"
  local -r appDir=${9:-'/usr/share/applications'}

  local startupWMClassEntry=''
  if [[ -n "$startupWMClass" ]]; then
     startupWMClassEntry="StartupWMClass=${startupWMClass}"
  fi
  # https://developer.gnome.org/menu-spec/
  local -r desktop_path="${appDir}/${fileName}.desktop"

  [[ ! -d "$appDir" ]] && {
    mkdir -p "$appDir" 2> /dev/null || sudo mkdir -p "$appDir"
  }

  local tee='tee'

  [[ "$(realpath "$appDir")" != '/home/'* ]] && {
    tee='sudo tee'
  }

  cat <<EOF | eval "$tee" "$desktop_path" > /dev/null
#!/usr/bin/env xdg-open
[Desktop Entry]
Name=${name}
Comment=${comment}
Categories=${categories}
Keywords=${keywords}
Exec=${exec}
Icon=${icon}
Terminal=false
Type=Application
${startupWMClassEntry}
EOF
  echo "Created desktop file: ${desktop_path}"
}
export -f create_desktop_file

apt-u(){ sudo apt update -y; }
export -f apt-u

apt-ug(){ sudo apt upgrade -y; }
export -f apt-ug

apt-i(){ sudo apt install -y "$@"; }
export -f apt-i

add_apt_key() {
	local -r apt_key="$1"
	sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys "$apt_key"
}
export -f add_apt_key

util_html_query_selector() {
  local -r url="$1"
  local -r selector="$2"
  local -r property="$3"

  dotf-i node &> /dev/null
  sudo npm install -g jsdom minimist &> /dev/null
  export NODE_PATH="$(npm root --quiet -g)"

  cat <<EOF | node - --url "$url" --selector "$selector" --property "$property"
// javascript
const jsdom = require("jsdom");
const { JSDOM } = jsdom;
const argv = require('minimist')(process.argv.slice(2));

const { url, selector, property } = argv;

const resourceLoader = new jsdom.ResourceLoader({
  userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36',
});
const options = {
  resources: resourceLoader
};

(async () => {
  try {
    const dom = await JSDOM.fromURL(url, options);
    const document = dom.window.document;
    const value = document.querySelector(selector)[property];
    console.log(value);
  } catch (error) {
    console.log(error.message);
    process.exit(1);
  }
})();
EOF
}

export -f util_html_query_selector
