#!/usr/bin/env bash

set -euEo pipefail

# Constants

export DEBIAN_FRONTEND=noninteractive

## Colors

export NOCOLOR='\033[0m'
export RED='\033[0;31m'
export GREEN='\033[0;32m'
# shellcheck disable=SC2034
export ORANGE='\033[0;33m'
export BLUE='\033[0;34m'
# shellcheck disable=SC2034
export PURPLE='\033[0;35m'
# shellcheck disable=SC2034
export CYAN='\033[0;36m'
# shellcheck disable=SC2034
export LIGHTGRAY='\033[0;37m'
# shellcheck disable=SC2034
export DARKGRAY='\033[1;30m'
# shellcheck disable=SC2034
export LIGHTRED='\033[1;31m'
export LIGHTGREEN='\033[1;32m'
export YELLOW='\033[1;33m'
export LIGHTBLUE='\033[1;34m'
# shellcheck disable=SC2034
export LIGHTPURPLE='\033[1;35m'
# shellcheck disable=SC2034
export LIGHTCYAN='\033[1;36m'
export WHITE='\033[1;37m'

## :Colors

if [[ -z "${BASE_PATH:-}" ]]; then
  readonly BASE_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi
if [[ -z "${WORK_DIR:-}" ]]; then
  readonly WORK_DIR="${WORK_DIR:-"$BASE_PATH"}"
fi

export PKGS_PATH="${WORK_DIR}/packages"
readonly PKGS_PATH
# export PKGS_PATH="${WORK_DIR}/packages"

set -o allexport
. "${WORK_DIR}/.env"
set +o allexport

# Functions

## echo functions

echoec() {
  local -r color="${2-$BLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "$*"
  else
    echo -e "${color}$*${NOCOLOR}" >&2
  fi
}
export -f echoec

echoc() {
  local -r color="${2-$BLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "$*"
  else
    echo -e "${color}$*${NOCOLOR}"
  fi
}
export -f echoc

err() {
  local -r color="${2-$RED}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "ERROR> $*" >&2
  else
    echo -e "${color}ERROR> $*${NOCOLOR}" >&2
  fi
}
export -f err

inf() {
  local -r color="${2-$LIGHTBLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e "INFO> $*"
  else
    echo -e "${color}INFO> $*${NOCOLOR}"
  fi
}
export -f inf

infn() {
  local -r color="${2-$LIGHTBLUE}"

  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo -e -n "INFO> $*"
  else
    echo -e -n "${color}INFO> $*${NOCOLOR}"
  fi
}
export -f infn

debug() {
  if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
    echo "DEBUG> $*"
  fi
}
export -f debug

## :echo functions

## dotfiles functions

__install_plugin() {
  local -r plugin="$1"

  local -r pkg="$plugin"
  local plugin_file_path="${PKGS_PATH}/${pkg}/${plugin}.plugin.bash"
  [[ ! -f "$plugin_file_path" ]] && plugin_file_path="${PKGS_PATH}/${pkg}/content/${plugin}.plugin.bash"
  local -r plugin_file_dest_path="${DOTF_BASH_PLUGINS_DIR}/${plugin}.plugin.bash"

  local -r msg="Installing bash plugin"

  inf "${msg}: ${plugin}"

  if [[ ! -f "$plugin_file_path" ]]; then
    err "${msg}: ${plugin}, plugin doesn't exist in: $plugin_file_path"
    return 10
  fi

  if [[ ! -d "$DOTF_BASH_PLUGINS_DIR" ]]; then
    err "${msg}: ${plugin}, plugins dir doesn't exist: $DOTF_BASH_PLUGINS_DIR"
    return 11
  fi

  ln --symbolic --verbose --force "$plugin_file_path" "$plugin_file_dest_path" || {
    err "${msg}: ${plugin}, creating link"
    return 12
  }

  if [[ ! -f "$DOTF_BASH_GEN_SETTINGS_FILE" ]] || ! grep --silent "BASHC_PLUGINS+=($plugin)" "$DOTF_BASH_GEN_SETTINGS_FILE"; then
    echo "BASHC_PLUGINS+=($plugin)" >> "$DOTF_BASH_GEN_SETTINGS_FILE" || {
      err "${msg}: ${plugin}, adding plugin to settings"
      return 13
    }
  fi

  inf "DONE. ${msg}: ${plugin}" "$GREEN"
  return 0
}
export -f __install_plugin

__install_package() {
  local -r pkg="$1"
  local -r force="${2:-false}"

  local -r pkg_dir="${PKGS_PATH}/${pkg}"
  local -r setup_file_path="${pkg_dir}/setup"
  local -r plugin_file_path="${pkg_dir}/${pkg}.plugin.bash"
  local -r plugin_file_path2="${pkg_dir}/content/${pkg}.plugin.bash"
  local -r pkg_home_path="${pkg_dir}/home"

  local -r msg='Installing package'

  if [[ ! -d "$pkg_dir" ]]; then
    err "${msg}: ${pkg}, package doesn't exist: ${pkg_dir}"
    return 10
  fi

  # Idempotent
  [[ "$force" == false ]] && type -P "$pkg" &>/dev/null && {
    inf "${pkg} currently installed"
    return 0
  }

  if [[ -f "$setup_file_path" ]]; then
    env PKG_CONTENT="${PKGS_PATH}/${pkg}/content" PKG_PATH="${PKGS_PATH}/${pkg}" bash "$setup_file_path" || {
      err "${msg}: ${pkg}, executing package setup"
      return 11
    }
  fi

  if [[ -f "$plugin_file_path" || -f "$plugin_file_path2" ]]; then
    __install_plugin "$pkg" || {
      err "${msg}: ${pkg}, installing bash plugin"
      return 12
    }
  fi

  if [[ -d "$pkg_home_path" ]]; then
    links2home "$pkg_home_path" &> /dev/null || {
      err "${msg}: ${pkg}, installing links2home"
      return 13
    }
  fi

  return 0
}
export -f __install_package

dotf-i() {
  local force=false

  local positional=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -f | --force)
      force=true
      shift
      ;;
    *)
      positional+=("$1")
      shift
      ;;
    esac
  done

  set -- "${positional[@]}" # restore local positional params
  local -r pkg="$1"
  # local -r color="\e[3$(( "$RANDOM" * 6 / 32767 + 1 ))m"

  __dotf_i_out() {
    local -i ecode=0

    if [[ -z "${ENV:-}" || "${ENV,,}" != 'production' ]]; then
      local -r msg="Installing package ${pkg}"
      echo -e "\n> ${msg}"
      if __install_package "$pkg" $force; then
        echo -e "> DONE. ${msg}"
      else
        ecode=$?
        echo -e "> FAIL. ${msg}"
      fi
    else
      local -r msg="${WHITE} Installing package${NOCOLOR} ${YELLOW}${pkg}${NOCOLOR}"
      echo -e "\n${WHITE}>${NOCOLOR}${msg}"
      if __install_package "$pkg" $force; then
        echo -e "${WHITE}>${NOCOLOR}${LIGHTGREEN} DONE.${msg}${NOCOLOR}"
      else
        ecode=$?
        echo -e "${WHITE}>${NOCOLOR}${LIGHTRED} FAIL.${msg}${NOCOLOR}"
      fi
    fi
    return $ecode
  }

  local out
  local -i ecode
  out="$(__dotf_i_out 2>&1)"
  ecode=$?

  echo -e "$out"

  if [[ $DOTF_LOG_ERRORS == true && $ecode -ne 0 ]]; then
cat <<EOF >> ~/.dotfiles.err.log

--------------------------------------------------------------
$(date +%Y%m%d-%H%M%S)
--------------------------------------------------------------
$out
EOF
  fi

  return $ecode
}
export -f dotf-i

## :dotfiles functions

create_desktop_file() {
  local -r name="$1"
  local -r comment="$2"
  local -r categories="$3"
  local -r keywords="$4"
  local -r exec="$5"
  local -r icon="$6"
  local -r startupWMClass=${7:-}
  local -r fileName="${8:-$name}"
  local -r appDir=${9:-'/usr/share/applications'}

  local startupWMClassEntry=''
  if [[ -n "$startupWMClass" ]]; then
    startupWMClassEntry="StartupWMClass=${startupWMClass}"
  fi
  # https://developer.gnome.org/menu-spec/
  local -r desktop_path="${appDir}/${fileName}.desktop"

  [[ ! -d "$appDir" ]] && {
    mkdir -p "$appDir" 2>/dev/null || sudo mkdir -p "$appDir"
  }

  local tee='tee'

  [[ "$(realpath "$appDir")" != '/home/'* ]] && {
    tee='sudo tee'
  }

  cat <<EOF | eval "$tee" "$desktop_path" >/dev/null
#!/usr/bin/env xdg-open
[Desktop Entry]
Name=${name}
Comment=${comment}
Categories=${categories}
Keywords=${keywords}
Exec=${exec}
Icon=${icon}
Terminal=false
Type=Application
${startupWMClassEntry}
EOF
  echo "Created desktop file: ${desktop_path}"
}
export -f create_desktop_file

apt-u() { sudo apt update -y; }
export -f apt-u

apt-ug() { sudo apt upgrade -y; }
export -f apt-ug

apt-i() { sudo apt install -y "$@"; }
export -f apt-i

add_apt_key() {
  local -r apt_key="$1"
  sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys "$apt_key"
}
export -f add_apt_key

util_html_query_selector() {
  local -r url="$1"
  local -r selector="$2"
  local -r property="$3"

  dotf-i node &>/dev/null
  # TODO instalar jsdom minimist en directorio temporal y después eliminar al final de esta función
  sudo npm install -g jsdom minimist &>/dev/null
  # poner a directorio temporal creado
  export NODE_PATH="$(npm root --quiet -g)"

  cat <<EOF | node - --url "$url" --selector "$selector" --property "$property"
// javascript
const jsdom = require("jsdom");
const { JSDOM } = jsdom;
const argv = require('minimist')(process.argv.slice(2));

const { url, selector, property } = argv;

const resourceLoader = new jsdom.ResourceLoader({
  userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36',
});
const options = {
  resources: resourceLoader
};

(async () => {
  try {
    const dom = await JSDOM.fromURL(url, options);
    const document = dom.window.document;
    const value = document.querySelector(selector)[property];
    console.log(value);
  } catch (error) {
    console.log(error.message);
    process.exit(1);
  }
})();
EOF
}

export -f util_html_query_selector

## Add custom keybinding
gnome_add_custom_keybinding() {
  local -r name="$1"
  local -r command="$2"
  local -r binding="$3"

  declare -ri custom_keybind_count=$(gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings | grep -Po '/custom-keybindings/custom' | wc -l)
  readonly keybind_id="custom${custom_keybind_count}"

  readonly path="/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/${keybind_id}/"
  readonly schema="org.gnome.settings-daemon.plugins.media-keys.custom-keybinding"

  custom_keybindings_new_value=''

  if [[ $custom_keybind_count -eq 0 ]]; then
    readonly custom_keybindings_new_value="['${path}']"
  else
    readonly custom_keybindings_new_value="$(gsettings get org.gnome.settings-daemon.plugins.media-keys custom-keybindings | sed 's/\]$//'), '${path}']"
  fi

  gsettings set org.gnome.settings-daemon.plugins.media-keys custom-keybindings "$custom_keybindings_new_value"

  gsettings set "${schema}:${path}" name "$name"
  gsettings set "${schema}:${path}" command "$command"
  gsettings set "${schema}:${path}" binding "$binding"
}
export -f gnome_add_custom_keybinding

links2home() {
  local -r directory="$1"

  (
    shopt -s dotglob

    cd "$directory"
    # I don't use stow because it create symlinks to folders, I don't want this
    while read -r file; do
      rel_file_path="${file#./}"
      file="${rel_file_path##*/}"
      rel_base_path="${rel_file_path%/*}"

      if [[ "$rel_file_path" != "$file" && ! -d ~/"$rel_base_path" ]]; then
        mkdir --parents --verbose ~/"$rel_base_path"
      fi
      ln --symbolic --force --verbose "${directory}/${rel_file_path}" ~/"${rel_file_path}"
    done < <(find . -type f)
  )
}

export -f links2home
